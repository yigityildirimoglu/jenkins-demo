// Pipeline'ın başlangıcı. Tüm iş akışı bu süslü parantezler içinde tanımlanır.
pipeline {
    // === GENEL AYARLAR ===

    // agent any: Bu satır ÇOK ÖNEMLİ. Jenkins'e, "Bu pipeline'ın adımlarını çalıştırmak için
    // varsayılan olarak BENİM kurulu olduğum sunucuyu (Sunucu A - Fabrika) kullan" der.
    // Lokaldeki 'agent { docker "dind" }' yapısından farklı, çünkü EC2'de Jenkins ve Docker
    // aynı sunucuda "kardeş" olarak yaşıyor ve 'jenkins' kullanıcısına Docker izni verdik.
    agent any

    // environment { ... }: Pipeline boyunca KULLANILACAK SABİT DEĞİŞKENLERİ burada tanımlarız.
    // Bu, kodun tekrarını azaltır ve yönetimi kolaylaştırır.
    environment {
        // --- Proje Ayarları ---
        COVERAGE_THRESHOLD = '50' // Birim testlerin kodun en az %50'sini kapsaması gerektiğini belirten kalite eşiği.
        DOCKER_IMAGE_NAME = 'yigittq/jenkins-demo-api' // Oluşturulacak ve push'lanacak Docker imajının Docker Hub'daki adı.
        DOCKER_TAG = "${env.BUILD_NUMBER}" // İmajı etiketlemek için Jenkins'in verdiği benzersiz build numarasını kullanırız (örn: 17, 18). Versiyonlama için harika!
        DOCKER_REGISTRY = 'docker.io' // Docker imaj deposunun adresi (Docker Hub için bu standarttır).

        // --- AWS Ayarları (Blue/Green için Gerekli) ---
        // Bu değerleri Jenkinsfile'a sabit yazmak yerine burada tanımlamak,
        // altyapı değişirse sadece burayı güncellemeyi sağlar.
        AWS_REGION = 'us-east-1' // AWS kaynaklarımızın bulunduğu bölge (ALB, EC2 vs.). AWS CLI komutları bu bilgiyi kullanır.
        // Aşağıdaki ARN'ler (Amazon Resource Name), AWS'teki kaynaklarımızın benzersiz kimlikleridir.
        // Bunları AWS konsolundan kopyalayıp buraya yapıştırdık. Jenkins bu kimlikleri kullanarak doğru kaynaklarla konuşur.
        ALB_LISTENER_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:listener/app/myy-app-alb/37b5761ecd032b70/06ce330922577902' // ALB'mizin HTTP:80 portunu dinleyen dinleyicisinin kimliği.
        ALB_RULE_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:listener-rule/app/myy-app-alb/37b5761ecd032b70/06ce330922577902/1afe0a8efa857a88' // Trafiği Blue/Green arasında YÖNLENDİREN KURALIN kimliği (Varsayılan olmayan, Priority 1 kuralı - çünkü varsayılanı değiştiremiyorduk!).
        BLUE_TG_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:targetgroup/blue-target-group/c30aa629d3539f3a' // Blue Hedef Grubu'nun kimliği.
        GREEN_TG_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:targetgroup/green-target-group/e2f25f519c58a5c1' // Green Hedef Grubu'nun kimliği.

        // --- Sunucu IP Adresleri ---
        // Deploy aşamasında SSH ile hangi sunucuya bağlanacağımızı bilmek için IP'leri burada tanımladık.
        BLUE_SERVER_IP = '54.87.26.234'  // Sunucu B (Blue) Public IP Adresi.
        GREEN_SERVER_IP = '18.209.12.9' // Sunucu C (Green) Public IP Adresi.
    }

    // stages { ... }: Pipeline'ın ana iş adımlarını (aşamalarını) içerir. Sırayla çalışırlar.
    stages {

        // === CI (SÜREKLİ ENTEGRASYON) AŞAMALARI ===
        // Bu aşamaların hepsi Jenkins Sunucusunda (Sunucu A) gerçekleşir.

        // --- Kodu Alma ---
        stage('Checkout') {
             // steps { ... }: Bir aşamanın içinde yapılacak işlemleri tanımlar. Olması ZORUNLUDUR.
             steps {
                echo 'Checking out code from Git...' // Konsola basit bir mesaj yazar.
                // checkout scm: Jenkins'in sihirli adımlarından biri. Proje ayarlarında
                // belirttiğin Git deposundan (URL, branch) kodu otomatik olarak çeker ve
                // Jenkins'in çalışma alanına (/var/lib/jenkins/workspace/...) kopyalar.
                checkout scm
            }
        }

        // --- Bağımlılıkları Kurma ve Testler (İzole Ortamlarda) ---
        // Bu sonraki 4 aşama benzer bir yapı kullanır:
        stage('Install Dependencies') {
            // agent { docker { ... } }: BU ÇOK ÖNEMLİ! Bu aşamanın, global 'agent any' yerine,
            // Jenkins'in (Sunucu A'daki Docker'ı kullanarak) geçici olarak başlatacağı bir Docker
            // konteyneri İÇİNDE çalışmasını sağlar. Bu, her testin temiz ve tutarlı bir
            // ortamda (Python 3.11) yapılmasını garanti eder.
            agent { docker { image 'python:3.11'; args '-u root' } } // 'python:3.11' imajını kullanır. '-u root' bazen izinler için gerekir.
            steps {
                echo 'Installing Python dependencies...'
                // sh '...': İçindeki komutu shell (kabuk) üzerinde çalıştırır. Bu komutlar
                // yukarıdaki agent tanımı nedeniyle Python 3.11 konteyneri İÇİNDE çalışır.
                sh 'pip install --quiet --upgrade pip' // pip'i günceller. --quiet daha az çıktı verir.
                sh 'pip install --quiet -r requirements.txt' // Projenin bağımlılıklarını kurar.
                // !!! OPTİMİZASYON NOKTASI 1: Bu 'pip install' komutları sonraki aşamalarda TEKRARLANIYOR!
            }
            // Bu aşama bitince, Jenkins bu Python konteynerini otomatik olarak durdurur ve SİLER.
        }

        stage('Lint') { // Kod stili ve temizlik kontrolü
            agent { docker { image 'python:3.11'; args '-u root' } } // YENİ, TEMİZ bir Python konteyneri başlatılır.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTİMİZASYON NOKTASI 2: Tekrar pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo 'Running code quality checks...'
                // flake8: Python kod stil denetleyicisi. .flake8 dosyasındaki kurallara göre kontrol eder.
                // ÖNEMLİ: Artık sonunda '|| true' yok. Eğer flake8 hata bulursa (exit code != 0),
                // bu 'sh' adımı başarısız olur ve pipeline DURUR. Bu, istediğimiz bir kalite kontrolüdür.
                sh 'flake8 app/ tests/ --config=.flake8'
            }
            // Konteyner silinir.
        }

        stage('Unit Tests') { // Kodun mantıksal doğruluğunu test etme
            agent { docker { image 'python:3.11'; args '-u root' } } // YENİ, TEMİZ bir Python konteyneri daha.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTİMİZASYON NOKTASI 3: Yine pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo 'Running unit tests with coverage...'
                // pytest: Popüler Python test çatısı.
                // --verbose: Daha detaylı çıktı.
                // --cov=app: 'app' klasöründeki kodun test kapsamını ölç.
                // --cov-report=...: Kapsam raporlarını farklı formatlarda (HTML, XML, Terminal) oluştur.
                // --junitxml=test-results.xml: Test sonuçlarını Jenkins'in anlayacağı JUnit XML formatında kaydet.
                sh '''
                    pytest tests/ --verbose --cov=app --cov-report=html:htmlcov \
                        --cov-report=xml:coverage.xml --cov-report=term-missing \
                        --junitxml=test-results.xml
                '''
                // Bu komutlar test/kapsam rapor dosyalarını (test-results.xml, coverage.xml, htmlcov/)
                // konteyner içinde oluşturur, ancak Jenkins bunları otomatik olarak ana çalışma alanına alır.
            }
            // Konteyner silinir.
        }

        stage('Coverage Check') { // Test kapsamının yeterli olup olmadığını kontrol etme
            agent { docker { image 'python:3.11'; args '-u root' } } // YENİ, TEMİZ bir Python konteyneri daha.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTİMİZASYON NOKTASI 4: Ve yine pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo "Checking coverage threshold (${COVERAGE_THRESHOLD}%)..." // environment'daki değişkeni kullanır.
                sh '''
                    # apt-get ... bc: Python coverage.xml'i okuyup matematiksel karşılaştırma
                    # yapabilmek için 'bc' (basic calculator) aracına ihtiyacımız var. Python imajında
                    # bu yüklü gelmediği için konteyner içinde kuruyoruz.
                    apt-get update -qq && apt-get install -y -qq bc > /dev/null 2>&1

                    # python -c "...": Tek satırlık Python script'i çalıştırır.
                    # Bu script, 'coverage.xml' dosyasını okur (ET = ElementTree XML parser),
                    # 'line-rate' (satır kapsam oranı) değerini alır ve yüzdesini ekrana basar.
                    coverage_percentage=$(python -c "
import xml.etree.ElementTree as ET
tree = ET.parse('coverage.xml')
root = tree.getroot()
line_rate = float(root.attrib['line-rate'])
print(f'{line_rate * 100:.2f}')
")
                    echo "Current coverage: ${coverage_percentage}%"
                    echo "Required coverage: ${COVERAGE_THRESHOLD}%"

                    # bc -l: 'bc' aracını kullanarak ondalıklı sayı karşılaştırması yapar.
                    # Eğer kapsam >= eşik ise '1' (true), değilse '0' (false) döndürür.
                    result=$(echo "$coverage_percentage >= ${COVERAGE_THRESHOLD}" | bc -l)
                    if [ "$result" -eq 1 ]; then
                        echo "✅ Coverage check passed!"
                    else
                        # Kapsam yetersizse 'exit 1' komutu çalışır. Bu, 'sh' adımının
                        # başarısız olmasına ve pipeline'ın DURMASINA neden olur. Bu da bir kalite kontrolüdür.
                        echo "❌ Coverage ${coverage_percentage}% is below threshold ${COVERAGE_THRESHOLD}%"
                        exit 1
                    fi
                '''
            }
            // Konteyner silinir.
        }

        // --- Paketleme (Docker İmajı Oluşturma) ---
        stage('Build Docker Image') {
            // Bu aşamada özel 'agent' yok, yani global 'agent any' (Sunucu A) kullanılır.
            steps {
                // script { ... }: İçine Groovy kodu yazmamızı sağlar (değişken tanımlama vb.).
                script {
                    echo '🐳 Building Docker image...'
                    // Groovy değişkenleri tanımlıyoruz (tag'leri oluşturmak için).
                    def imageTag = "${DOCKER_IMAGE_NAME}:${DOCKER_TAG}" // Örn: yigittq/jenkins-demo-api:17
                    def imageLatest = "${DOCKER_IMAGE_NAME}:latest" // Örn: yigittq/jenkins-demo-api:latest
                    // sh "docker build ...": Docker build komutunu Sunucu A üzerinde çalıştırır.
                    // Bu komut çalışır çünkü Jenkins'e Docker izni vermiştik (usermod).
                    // '.' -> Koddaki Dockerfile'ı kullanır.
                    // -t -> İmaja etiket (tag) verir. İki etiket veriyoruz: build numarası ve 'latest'.
                    sh "docker build -t ${imageTag} -t ${imageLatest} ."
                    echo "✅ Docker image built: ${imageTag}, ${imageLatest}"
                }
            }
        }

        // --- Depoya Gönderme (Docker Hub) ---
        stage('Push to Docker Hub') {
            // Yine 'agent any' (Sunucu A) üzerinde çalışır.
            steps {
                script {
                    echo '📤 Pushing Docker image to Docker Hub...'
                    def imageTag = "${DOCKER_IMAGE_NAME}:${DOCKER_TAG}"
                    def imageLatest = "${DOCKER_IMAGE_NAME}:latest"
                    // withCredentials { ... }: Jenkins'in kasasındaki sırları GÜVENLİ bir şekilde kullanmamızı sağlar.
                    // usernamePassword(...): 'Username with password' türündeki sırları yükler.
                    // credentialsId: 'dockerhub-credentials': Jenkins'e hangi sırrı kullanacağını söyler (Adım 1.11'de eklemiştik).
                    // usernameVariable/passwordVariable: Sırları hangi GEÇİCİ ortam değişkenlerine yükleyeceğini belirtir.
                    // BU BLOK BİTİNCE BU DEĞİŞKENLER OTOMATİK OLARAK SİLİNİR! Bu yüzden güvenlidir.
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        // sh """...""": Çok satırlı shell script'i çalıştırır.
                        sh """
                            echo "🔐 Logging in to Docker Hub..."
                            # ${DOCKER_PASS} değişkeni withCredentials sayesinde burada kullanılabilir.
                            # --password-stdin: Şifreyi komut satırına yazmak yerine pipe (|) ile güvenli alır.
                            echo "${DOCKER_PASS}" | docker login -u ${DOCKER_USER} --password-stdin
                            echo "📤 Pushing ${imageTag}..."
                            docker push ${imageTag} // Build numaralı tag'i push'lar.
                            echo "📤 Pushing ${imageLatest}..."
                            docker push ${imageLatest} // 'latest' tag'ini push'lar.
                            echo "✅ Docker images pushed successfully!"
                        """
                    } // withCredentials bloğu biter, DOCKER_USER ve DOCKER_PASS silinir.
                }
            }
        } // CI AŞAMALARI BİTTİ! İmajımız Docker Hub'da.

        // === CD (SÜREKLİ DAĞITIM) AŞAMASI: Blue/Green ===
        // Bu aşama Jenkins Sunucusunda (Sunucu A) başlar ama komutları SSH ile
        // Deploy Sunucularına (B veya C) gönderir ve AWS API'sini kullanarak ALB'yi yönetir.
        stage('Deploy Blue/Green') {
            steps { // Tüm adımlar 'steps' içinde olmalı (Adım 6.2'deki hatayı düzelttik).
                // withCredentials { ... }: Bu sefer AWS kimlik bilgilerini yüklüyoruz.
                // [[$class: 'AmazonWebServicesCredentialsBinding', ...]]: AWS Credential türünü belirtir.
                // credentialsId: 'aws-deploy-credentials': Jenkins kasasındaki AWS anahtarlarımızın ID'si (Adım 5.3'te ekledik).
                // Bu blok sayesinde içerideki 'aws' CLI komutları otomatik olarak yetkilendirilir.
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-deploy-credentials']]) {
                    // script { ... }: Karmaşık Groovy mantığı (if/else, değişken atama) için gereklidir.
                    script {
                        // --- Adım 1: Canlı Ortamı Bul ---
                        echo "Determining current LIVE environment by querying ALB Rule..."
                        // sh(script: "...", returnStdout: true).trim(): Jenkins'in bir shell komutunun
                        // ÇIKTISINI yakalayıp bir Groovy değişkenine atamasını sağlar.
                        def liveTargetGroupArn = sh(
                            script: """
                                # aws elbv2 describe-rules: AWS CLI komutu, ALB kuralının detaylarını getirir.
                                aws elbv2 describe-rules --rule-arn ${env.ALB_RULE_ARN} \\
                                    # --query '...': AWS CLI'nın JSON çıktısını filtreleyerek sadece ihtiyacımız olan
                                    # (ilk kuralın ilk eyleminin hedef grup ARN'si) değeri alırız.
                                    --query 'Rules[0].Actions[0].TargetGroupArn' --output text --region ${env.AWS_REGION}
                            """,
                            returnStdout: true // Çıktıyı yakala
                        ).trim() // Baştaki/sondaki boşlukları temizle

                        // Groovy değişkenleri tanımlıyoruz (sonraki adımlarda kullanmak için).
                        def deployTargetGroupArn // Hangi hedef gruba deploy edeceğiz?
                        def deployServerIp       // Hangi sunucu IP'sine deploy edeceğiz?
                        def deployTgFriendlyName // Loglarda 'BLUE'/'GREEN' yazdırmak için.
                        def liveServerIp         // Şu an canlı olan sunucunun IP'si (sadece log için).

                        // if/else if bloğu: Yakaladığımız 'liveTargetGroupArn' değerine göre karar veriyoruz.
                        if (liveTargetGroupArn == env.BLUE_TG_ARN) { // Eğer canlı olan Blue ise...
                            echo "Blue environment (${env.BLUE_SERVER_IP}) is LIVE. Deploying to GREEN."
                            // ... deploy'u Green'e yapacağız. Değişkenleri Green'in bilgileriyle dolduruyoruz.
                            deployTargetGroupArn = env.GREEN_TG_ARN
                            deployServerIp = env.GREEN_SERVER_IP
                            deployTgFriendlyName = "GREEN"
                            liveServerIp = env.BLUE_SERVER_IP
                        } else if (liveTargetGroupArn == env.GREEN_TG_ARN) { // Eğer canlı olan Green ise...
                            echo "Green environment (${env.GREEN_SERVER_IP}) is LIVE. Deploying to BLUE."
                            // ... deploy'u Blue'ya yapacağız. Değişkenleri Blue'nun bilgileriyle dolduruyoruz.
                            deployTargetGroupArn = env.BLUE_TG_ARN
                            deployServerIp = env.BLUE_SERVER_IP
                            deployTgFriendlyName = "BLUE"
                            liveServerIp = env.GREEN_SERVER_IP
                        } else {
                            // error '...': Bir sorun varsa (örn: kural beklenmedik bir yere gidiyorsa)
                            // pipeline'ı HATA mesajıyla durdurur. Güvenlik önlemi.
                            error "ALB Rule is pointing to an unknown Target Group ARN: ${liveTargetGroupArn}"
                        } // Canlı/Boşta ortamlar belirlendi. 'deployServerIp' artık boşta olan sunucuyu gösteriyor.

                        // --- Adım 2: Boştaki Sunucuya Deploy Et ---
                        echo "Deploying image ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG} to IDLE [${deployTgFriendlyName}] server: ${deployServerIp}"
                        // withCredentials (iç içe): Hem Docker Hub hem de SSH anahtarını aynı anda yüklememiz gerekiyor.
                        withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                            // sshagent { ... }: Jenkins kasasındaki SSH özel anahtarını ('deploy-server-ssh-key' - Adım 3.3'te ekledik)
                            // güvenli bir şekilde yükler. İçindeki 'sh "ssh ..."' komutu bu anahtarı kullanarak şifresiz bağlanır.
                            sshagent(credentials: ['deploy-server-ssh-key']) {
                                // sh """ssh ... '...'""": Uzak sunucuda (boştaki sunucu - deployServerIp) komut çalıştırır.
                                sh """
                                    # -o StrictHostKeyChecking=no: İlk bağlantıda "yes/no" sormasını engeller (otomasyon için).
                                    ssh -o StrictHostKeyChecking=no ec2-user@${deployServerIp} '
                                        # Tek tırnak (') içindeki HER ŞEY UZAK SUNUCUDA (B veya C) çalışır.
                                        echo "🎯 [${deployServerIp}] Connected!"
                                        echo "🔐 [${deployServerIp}] Logging in to Docker Hub..."
                                        # \${...} KULLANIMI ÇOK ÖNEMLİ (Adım 4'teki Sorun 11/12'yi çözdü):
                                        # Jenkinsfile Groovy'dir. Eğer sadece ${DOCKER_PASS} yazsaydık, Groovy bunu Sunucu A'da
                                        # çözmeye çalışırdı ve SSH komutuna şifreyi açık metin olarak gömerdi (güvensiz).
                                        # Başına '\' koyarak Groovy'e "buna dokunma" diyoruz. Bu sayede ${DOCKER_PASS} ifadesi
                                        # olduğu gibi uzak sunucunun SHELL'ine gider ve SHELL bunu doğru şekilde çözer.
                                        echo "\${DOCKER_PASS}" | docker login -u "\${DOCKER_USER}" --password-stdin

                                        echo "🐳 [${deployServerIp}] Pulling image: ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}"
                                        # Uzak sunucu, Docker Hub'dan yeni imajı çeker.
                                        docker pull ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}

                                        echo "🛑 [${deployServerIp}] Stopping old container..."
                                        # || true: Eğer önceki deploy'dan kalan konteyner yoksa hata vermeden devam etmesini sağlar.
                                        docker stop jenkins-demo-app || true
                                        docker rm jenkins-demo-app || true

                                        echo "🚀 [${deployServerIp}] Starting new container on port 8001..."
                                        # Yeni imajla konteyneri başlatır. Host'un 8001 portunu konteynerin 8000'ine bağlar.
                                        docker run -d --name jenkins-demo-app -p 8001:8000 ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}

                                        echo "🧹 [${deployServerIp}] Pruning old images..."
                                        # Uzak sunucudaki eski, kullanılmayan Docker imajlarını temizler (disk tasarrufu).
                                        docker image prune -f

                                        echo "✅ [${deployServerIp}] Deployment script finished."
                                    '
                                """
                            } // sshagent biter, SSH anahtarı hafızadan silinir.
                        } // withCredentials (Docker Hub) biter.

                        // --- Adım 3: Sağlık Kontrolü ---
                        echo "Waiting for application to start on [${deployTgFriendlyName}] server (${deployServerIp}) before health check..."
                        // sleep(15): Docker konteynerinin ayağa kalkması ve uygulamanın cevap vermeye başlaması
                        // biraz zaman alabilir. Kontrol etmeden önce kısa bir süre beklemek önemlidir.
                        sleep(15)

                        echo "Performing health check on [${deployTgFriendlyName}] server: http://${deployServerIp}:8001/health"
                        // try { ... } catch (ex) { ... }: Hata yakalama bloğu. Sağlık kontrolü başarısız olursa
                        // pipeline'ın devam etmesini engeller.
                        try {
                            // sh "curl ...": Jenkins sunucusundan (A), yeni deploy edilen sunucunun (B veya C)
                            // IP adresine DOĞRUDAN bir HTTP isteği göndeririz (/health endpoint'ine).
                            // -f: HTTP 4xx/5xx hatası alırsa curl'un hata koduyla çıkmasını sağlar (catch'i tetikler).
                            // -sS: Sessiz çalışır ama hata olursa gösterir.
                            sh "curl -fsS http://${deployServerIp}:8001/health"
                            echo "✅ [${deployTgFriendlyName}] Health check PASSED."
                        } catch (ex) { // Eğer 'sh "curl..."' komutu hata verirse (uygulama cevap vermezse veya hata dönerse) burası çalışır.
                            echo "❌ [${deployTgFriendlyName}] Health check FAILED! See details below:"
                            echo ex.getMessage() // Hatayı konsola yazdırır.
                            // error '...': Pipeline'ı BAŞARISIZ olarak işaretler ve durdurur. Trafik çevrilmez!
                            error "Deployment failed health check. Traffic switch aborted."
                        } // try-catch biter. Buraya ulaştıysak sağlık kontrolü başarılıdır.

                        // --- Adım 4: Trafiği Çevirme ---
                        echo "Health check passed. Flipping ALB traffic to target group [${deployTgFriendlyName}] (${deployTargetGroupArn})..."
                        // sh """aws ...""": AWS CLI komutunu kullanarak ALB kuralını güncelleriz.
                        sh """
                            aws elbv2 modify-rule --rule-arn ${env.ALB_RULE_ARN} \\
                                # --actions Type=forward,TargetGroupArn=...: Kuralın hedefini, yeni deploy ettiğimiz
                                # ve sağlık kontrolünü geçen hedef gruba (deployTargetGroupArn) yönlendirir.
                                --actions Type=forward,TargetGroupArn=${deployTargetGroupArn} \\
                                --region ${env.AWS_REGION}
                        """
                        // BU KOMUT TRAFİĞİ ANINDA ÇEVİRİR! Sıfır kesinti burada gerçekleşir.
                        // ⚠️ Karşılaşılan Sorun 15'i hatırlayalım: Eğer burada varsayılan kuralın ARN'sini
                        // kullansaydık, bu komut 'Default rule cannot be modified' hatası verirdi.

                        echo "✅ SUCCESS! Traffic is now flowing to [${deployTgFriendlyName}]."
                        echo "Old environment (Server IP: ${liveServerIp}) is now idle." // Eski canlı sunucunun artık boşta olduğunu loglarız.
                    } // script bloğu biter.
                } // withCredentials [AWS] bloğu biter. AWS anahtarları hafızadan silinir.
            } // steps bloğu biter.
        } // stage 'Deploy Blue/Green' biter.
    } // stages bloğu biter.

    // === POST ACTIONS (Pipeline Bittikten Sonra Çalışır) ===
    // post { ... }: Pipeline bittikten sonra (başarılı veya başarısız) yapılacak ek işlemleri tanımlar.
    post {
        // always { ... }: Pipeline başarılı da olsa başarısız da olsa HER ZAMAN çalışır.
        always {
             // junit ...: Unit test aşamasında oluşturulan 'test-results.xml' dosyasını okur
             // ve Jenkins arayüzünde güzel bir test raporu gösterir.
             junit testResults: 'test-results.xml', allowEmptyResults: true
             // publishHTML ...: Unit test aşamasında oluşturulan 'htmlcov' klasöründeki
             // HTML kapsam raporunu Jenkins arayüzünde yayınlar.
             publishHTML(
                allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true,
                reportDir: 'htmlcov', reportFiles: 'index.html', reportName: 'Coverage Report'
             )
             // Bu raporlamalar, build sonuçlarını takip etmek ve analiz etmek için çok değerlidir.
        }
        // success { ... }: Sadece pipeline BAŞARILI olursa çalışır.
        success {
            echo '✅ Pipeline completed successfully!'
        }
        // failure { ... }: Sadece pipeline BAŞARISIZ olursa çalışır.
        failure {
            echo '❌ Pipeline failed!'
        }
    }
} // pipeline biter.