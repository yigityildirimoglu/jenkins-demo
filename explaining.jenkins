// Pipeline'Ä±n baÅŸlangÄ±cÄ±. TÃ¼m iÅŸ akÄ±ÅŸÄ± bu sÃ¼slÃ¼ parantezler iÃ§inde tanÄ±mlanÄ±r.
pipeline {
    // === GENEL AYARLAR ===

    // agent any: Bu satÄ±r Ã‡OK Ã–NEMLÄ°. Jenkins'e, "Bu pipeline'Ä±n adÄ±mlarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in
    // varsayÄ±lan olarak BENÄ°M kurulu olduÄŸum sunucuyu (Sunucu A - Fabrika) kullan" der.
    // Lokaldeki 'agent { docker "dind" }' yapÄ±sÄ±ndan farklÄ±, Ã§Ã¼nkÃ¼ EC2'de Jenkins ve Docker
    // aynÄ± sunucuda "kardeÅŸ" olarak yaÅŸÄ±yor ve 'jenkins' kullanÄ±cÄ±sÄ±na Docker izni verdik.
    agent any

    // environment { ... }: Pipeline boyunca KULLANILACAK SABÄ°T DEÄÄ°ÅKENLERÄ° burada tanÄ±mlarÄ±z.
    // Bu, kodun tekrarÄ±nÄ± azaltÄ±r ve yÃ¶netimi kolaylaÅŸtÄ±rÄ±r.
    environment {
        // --- Proje AyarlarÄ± ---
        COVERAGE_THRESHOLD = '50' // Birim testlerin kodun en az %50'sini kapsamasÄ± gerektiÄŸini belirten kalite eÅŸiÄŸi.
        DOCKER_IMAGE_NAME = 'yigittq/jenkins-demo-api' // OluÅŸturulacak ve push'lanacak Docker imajÄ±nÄ±n Docker Hub'daki adÄ±.
        DOCKER_TAG = "${env.BUILD_NUMBER}" // Ä°majÄ± etiketlemek iÃ§in Jenkins'in verdiÄŸi benzersiz build numarasÄ±nÄ± kullanÄ±rÄ±z (Ã¶rn: 17, 18). Versiyonlama iÃ§in harika!
        DOCKER_REGISTRY = 'docker.io' // Docker imaj deposunun adresi (Docker Hub iÃ§in bu standarttÄ±r).

        // --- AWS AyarlarÄ± (Blue/Green iÃ§in Gerekli) ---
        // Bu deÄŸerleri Jenkinsfile'a sabit yazmak yerine burada tanÄ±mlamak,
        // altyapÄ± deÄŸiÅŸirse sadece burayÄ± gÃ¼ncellemeyi saÄŸlar.
        AWS_REGION = 'us-east-1' // AWS kaynaklarÄ±mÄ±zÄ±n bulunduÄŸu bÃ¶lge (ALB, EC2 vs.). AWS CLI komutlarÄ± bu bilgiyi kullanÄ±r.
        // AÅŸaÄŸÄ±daki ARN'ler (Amazon Resource Name), AWS'teki kaynaklarÄ±mÄ±zÄ±n benzersiz kimlikleridir.
        // BunlarÄ± AWS konsolundan kopyalayÄ±p buraya yapÄ±ÅŸtÄ±rdÄ±k. Jenkins bu kimlikleri kullanarak doÄŸru kaynaklarla konuÅŸur.
        ALB_LISTENER_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:listener/app/myy-app-alb/37b5761ecd032b70/06ce330922577902' // ALB'mizin HTTP:80 portunu dinleyen dinleyicisinin kimliÄŸi.
        ALB_RULE_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:listener-rule/app/myy-app-alb/37b5761ecd032b70/06ce330922577902/1afe0a8efa857a88' // TrafiÄŸi Blue/Green arasÄ±nda YÃ–NLENDÄ°REN KURALIN kimliÄŸi (VarsayÄ±lan olmayan, Priority 1 kuralÄ± - Ã§Ã¼nkÃ¼ varsayÄ±lanÄ± deÄŸiÅŸtiremiyorduk!).
        BLUE_TG_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:targetgroup/blue-target-group/c30aa629d3539f3a' // Blue Hedef Grubu'nun kimliÄŸi.
        GREEN_TG_ARN = 'arn:aws:elasticloadbalancing:us-east-1:339712914983:targetgroup/green-target-group/e2f25f519c58a5c1' // Green Hedef Grubu'nun kimliÄŸi.

        // --- Sunucu IP Adresleri ---
        // Deploy aÅŸamasÄ±nda SSH ile hangi sunucuya baÄŸlanacaÄŸÄ±mÄ±zÄ± bilmek iÃ§in IP'leri burada tanÄ±mladÄ±k.
        BLUE_SERVER_IP = '54.87.26.234'  // Sunucu B (Blue) Public IP Adresi.
        GREEN_SERVER_IP = '18.209.12.9' // Sunucu C (Green) Public IP Adresi.
    }

    // stages { ... }: Pipeline'Ä±n ana iÅŸ adÄ±mlarÄ±nÄ± (aÅŸamalarÄ±nÄ±) iÃ§erir. SÄ±rayla Ã§alÄ±ÅŸÄ±rlar.
    stages {

        // === CI (SÃœREKLÄ° ENTEGRASYON) AÅAMALARI ===
        // Bu aÅŸamalarÄ±n hepsi Jenkins Sunucusunda (Sunucu A) gerÃ§ekleÅŸir.

        // --- Kodu Alma ---
        stage('Checkout') {
             // steps { ... }: Bir aÅŸamanÄ±n iÃ§inde yapÄ±lacak iÅŸlemleri tanÄ±mlar. OlmasÄ± ZORUNLUDUR.
             steps {
                echo 'Checking out code from Git...' // Konsola basit bir mesaj yazar.
                // checkout scm: Jenkins'in sihirli adÄ±mlarÄ±ndan biri. Proje ayarlarÄ±nda
                // belirttiÄŸin Git deposundan (URL, branch) kodu otomatik olarak Ã§eker ve
                // Jenkins'in Ã§alÄ±ÅŸma alanÄ±na (/var/lib/jenkins/workspace/...) kopyalar.
                checkout scm
            }
        }

        // --- BaÄŸÄ±mlÄ±lÄ±klarÄ± Kurma ve Testler (Ä°zole Ortamlarda) ---
        // Bu sonraki 4 aÅŸama benzer bir yapÄ± kullanÄ±r:
        stage('Install Dependencies') {
            // agent { docker { ... } }: BU Ã‡OK Ã–NEMLÄ°! Bu aÅŸamanÄ±n, global 'agent any' yerine,
            // Jenkins'in (Sunucu A'daki Docker'Ä± kullanarak) geÃ§ici olarak baÅŸlatacaÄŸÄ± bir Docker
            // konteyneri Ä°Ã‡Ä°NDE Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar. Bu, her testin temiz ve tutarlÄ± bir
            // ortamda (Python 3.11) yapÄ±lmasÄ±nÄ± garanti eder.
            agent { docker { image 'python:3.11'; args '-u root' } } // 'python:3.11' imajÄ±nÄ± kullanÄ±r. '-u root' bazen izinler iÃ§in gerekir.
            steps {
                echo 'Installing Python dependencies...'
                // sh '...': Ä°Ã§indeki komutu shell (kabuk) Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±r. Bu komutlar
                // yukarÄ±daki agent tanÄ±mÄ± nedeniyle Python 3.11 konteyneri Ä°Ã‡Ä°NDE Ã§alÄ±ÅŸÄ±r.
                sh 'pip install --quiet --upgrade pip' // pip'i gÃ¼nceller. --quiet daha az Ã§Ä±ktÄ± verir.
                sh 'pip install --quiet -r requirements.txt' // Projenin baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± kurar.
                // !!! OPTÄ°MÄ°ZASYON NOKTASI 1: Bu 'pip install' komutlarÄ± sonraki aÅŸamalarda TEKRARLANIYOR!
            }
            // Bu aÅŸama bitince, Jenkins bu Python konteynerini otomatik olarak durdurur ve SÄ°LER.
        }

        stage('Lint') { // Kod stili ve temizlik kontrolÃ¼
            agent { docker { image 'python:3.11'; args '-u root' } } // YENÄ°, TEMÄ°Z bir Python konteyneri baÅŸlatÄ±lÄ±r.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTÄ°MÄ°ZASYON NOKTASI 2: Tekrar pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo 'Running code quality checks...'
                // flake8: Python kod stil denetleyicisi. .flake8 dosyasÄ±ndaki kurallara gÃ¶re kontrol eder.
                // Ã–NEMLÄ°: ArtÄ±k sonunda '|| true' yok. EÄŸer flake8 hata bulursa (exit code != 0),
                // bu 'sh' adÄ±mÄ± baÅŸarÄ±sÄ±z olur ve pipeline DURUR. Bu, istediÄŸimiz bir kalite kontrolÃ¼dÃ¼r.
                sh 'flake8 app/ tests/ --config=.flake8'
            }
            // Konteyner silinir.
        }

        stage('Unit Tests') { // Kodun mantÄ±ksal doÄŸruluÄŸunu test etme
            agent { docker { image 'python:3.11'; args '-u root' } } // YENÄ°, TEMÄ°Z bir Python konteyneri daha.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTÄ°MÄ°ZASYON NOKTASI 3: Yine pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo 'Running unit tests with coverage...'
                // pytest: PopÃ¼ler Python test Ã§atÄ±sÄ±.
                // --verbose: Daha detaylÄ± Ã§Ä±ktÄ±.
                // --cov=app: 'app' klasÃ¶rÃ¼ndeki kodun test kapsamÄ±nÄ± Ã¶lÃ§.
                // --cov-report=...: Kapsam raporlarÄ±nÄ± farklÄ± formatlarda (HTML, XML, Terminal) oluÅŸtur.
                // --junitxml=test-results.xml: Test sonuÃ§larÄ±nÄ± Jenkins'in anlayacaÄŸÄ± JUnit XML formatÄ±nda kaydet.
                sh '''
                    pytest tests/ --verbose --cov=app --cov-report=html:htmlcov \
                        --cov-report=xml:coverage.xml --cov-report=term-missing \
                        --junitxml=test-results.xml
                '''
                // Bu komutlar test/kapsam rapor dosyalarÄ±nÄ± (test-results.xml, coverage.xml, htmlcov/)
                // konteyner iÃ§inde oluÅŸturur, ancak Jenkins bunlarÄ± otomatik olarak ana Ã§alÄ±ÅŸma alanÄ±na alÄ±r.
            }
            // Konteyner silinir.
        }

        stage('Coverage Check') { // Test kapsamÄ±nÄ±n yeterli olup olmadÄ±ÄŸÄ±nÄ± kontrol etme
            agent { docker { image 'python:3.11'; args '-u root' } } // YENÄ°, TEMÄ°Z bir Python konteyneri daha.
            steps {
                echo 'Installing Python dependencies...'
                sh 'pip install --quiet --upgrade pip' // !!! OPTÄ°MÄ°ZASYON NOKTASI 4: Ve yine pip install!
                sh 'pip install --quiet -r requirements.txt'
                echo "Checking coverage threshold (${COVERAGE_THRESHOLD}%)..." // environment'daki deÄŸiÅŸkeni kullanÄ±r.
                sh '''
                    # apt-get ... bc: Python coverage.xml'i okuyup matematiksel karÅŸÄ±laÅŸtÄ±rma
                    # yapabilmek iÃ§in 'bc' (basic calculator) aracÄ±na ihtiyacÄ±mÄ±z var. Python imajÄ±nda
                    # bu yÃ¼klÃ¼ gelmediÄŸi iÃ§in konteyner iÃ§inde kuruyoruz.
                    apt-get update -qq && apt-get install -y -qq bc > /dev/null 2>&1

                    # python -c "...": Tek satÄ±rlÄ±k Python script'i Ã§alÄ±ÅŸtÄ±rÄ±r.
                    # Bu script, 'coverage.xml' dosyasÄ±nÄ± okur (ET = ElementTree XML parser),
                    # 'line-rate' (satÄ±r kapsam oranÄ±) deÄŸerini alÄ±r ve yÃ¼zdesini ekrana basar.
                    coverage_percentage=$(python -c "
import xml.etree.ElementTree as ET
tree = ET.parse('coverage.xml')
root = tree.getroot()
line_rate = float(root.attrib['line-rate'])
print(f'{line_rate * 100:.2f}')
")
                    echo "Current coverage: ${coverage_percentage}%"
                    echo "Required coverage: ${COVERAGE_THRESHOLD}%"

                    # bc -l: 'bc' aracÄ±nÄ± kullanarak ondalÄ±klÄ± sayÄ± karÅŸÄ±laÅŸtÄ±rmasÄ± yapar.
                    # EÄŸer kapsam >= eÅŸik ise '1' (true), deÄŸilse '0' (false) dÃ¶ndÃ¼rÃ¼r.
                    result=$(echo "$coverage_percentage >= ${COVERAGE_THRESHOLD}" | bc -l)
                    if [ "$result" -eq 1 ]; then
                        echo "âœ… Coverage check passed!"
                    else
                        # Kapsam yetersizse 'exit 1' komutu Ã§alÄ±ÅŸÄ±r. Bu, 'sh' adÄ±mÄ±nÄ±n
                        # baÅŸarÄ±sÄ±z olmasÄ±na ve pipeline'Ä±n DURMASINA neden olur. Bu da bir kalite kontrolÃ¼dÃ¼r.
                        echo "âŒ Coverage ${coverage_percentage}% is below threshold ${COVERAGE_THRESHOLD}%"
                        exit 1
                    fi
                '''
            }
            // Konteyner silinir.
        }

        // --- Paketleme (Docker Ä°majÄ± OluÅŸturma) ---
        stage('Build Docker Image') {
            // Bu aÅŸamada Ã¶zel 'agent' yok, yani global 'agent any' (Sunucu A) kullanÄ±lÄ±r.
            steps {
                // script { ... }: Ä°Ã§ine Groovy kodu yazmamÄ±zÄ± saÄŸlar (deÄŸiÅŸken tanÄ±mlama vb.).
                script {
                    echo 'ğŸ³ Building Docker image...'
                    // Groovy deÄŸiÅŸkenleri tanÄ±mlÄ±yoruz (tag'leri oluÅŸturmak iÃ§in).
                    def imageTag = "${DOCKER_IMAGE_NAME}:${DOCKER_TAG}" // Ã–rn: yigittq/jenkins-demo-api:17
                    def imageLatest = "${DOCKER_IMAGE_NAME}:latest" // Ã–rn: yigittq/jenkins-demo-api:latest
                    // sh "docker build ...": Docker build komutunu Sunucu A Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±r.
                    // Bu komut Ã§alÄ±ÅŸÄ±r Ã§Ã¼nkÃ¼ Jenkins'e Docker izni vermiÅŸtik (usermod).
                    // '.' -> Koddaki Dockerfile'Ä± kullanÄ±r.
                    // -t -> Ä°maja etiket (tag) verir. Ä°ki etiket veriyoruz: build numarasÄ± ve 'latest'.
                    sh "docker build -t ${imageTag} -t ${imageLatest} ."
                    echo "âœ… Docker image built: ${imageTag}, ${imageLatest}"
                }
            }
        }

        // --- Depoya GÃ¶nderme (Docker Hub) ---
        stage('Push to Docker Hub') {
            // Yine 'agent any' (Sunucu A) Ã¼zerinde Ã§alÄ±ÅŸÄ±r.
            steps {
                script {
                    echo 'ğŸ“¤ Pushing Docker image to Docker Hub...'
                    def imageTag = "${DOCKER_IMAGE_NAME}:${DOCKER_TAG}"
                    def imageLatest = "${DOCKER_IMAGE_NAME}:latest"
                    // withCredentials { ... }: Jenkins'in kasasÄ±ndaki sÄ±rlarÄ± GÃœVENLÄ° bir ÅŸekilde kullanmamÄ±zÄ± saÄŸlar.
                    // usernamePassword(...): 'Username with password' tÃ¼rÃ¼ndeki sÄ±rlarÄ± yÃ¼kler.
                    // credentialsId: 'dockerhub-credentials': Jenkins'e hangi sÄ±rrÄ± kullanacaÄŸÄ±nÄ± sÃ¶yler (AdÄ±m 1.11'de eklemiÅŸtik).
                    // usernameVariable/passwordVariable: SÄ±rlarÄ± hangi GEÃ‡Ä°CÄ° ortam deÄŸiÅŸkenlerine yÃ¼kleyeceÄŸini belirtir.
                    // BU BLOK BÄ°TÄ°NCE BU DEÄÄ°ÅKENLER OTOMATÄ°K OLARAK SÄ°LÄ°NÄ°R! Bu yÃ¼zden gÃ¼venlidir.
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        // sh """...""": Ã‡ok satÄ±rlÄ± shell script'i Ã§alÄ±ÅŸtÄ±rÄ±r.
                        sh """
                            echo "ğŸ” Logging in to Docker Hub..."
                            # ${DOCKER_PASS} deÄŸiÅŸkeni withCredentials sayesinde burada kullanÄ±labilir.
                            # --password-stdin: Åifreyi komut satÄ±rÄ±na yazmak yerine pipe (|) ile gÃ¼venli alÄ±r.
                            echo "${DOCKER_PASS}" | docker login -u ${DOCKER_USER} --password-stdin
                            echo "ğŸ“¤ Pushing ${imageTag}..."
                            docker push ${imageTag} // Build numaralÄ± tag'i push'lar.
                            echo "ğŸ“¤ Pushing ${imageLatest}..."
                            docker push ${imageLatest} // 'latest' tag'ini push'lar.
                            echo "âœ… Docker images pushed successfully!"
                        """
                    } // withCredentials bloÄŸu biter, DOCKER_USER ve DOCKER_PASS silinir.
                }
            }
        } // CI AÅAMALARI BÄ°TTÄ°! Ä°majÄ±mÄ±z Docker Hub'da.

        // === CD (SÃœREKLÄ° DAÄITIM) AÅAMASI: Blue/Green ===
        // Bu aÅŸama Jenkins Sunucusunda (Sunucu A) baÅŸlar ama komutlarÄ± SSH ile
        // Deploy SunucularÄ±na (B veya C) gÃ¶nderir ve AWS API'sini kullanarak ALB'yi yÃ¶netir.
        stage('Deploy Blue/Green') {
            steps { // TÃ¼m adÄ±mlar 'steps' iÃ§inde olmalÄ± (AdÄ±m 6.2'deki hatayÄ± dÃ¼zelttik).
                // withCredentials { ... }: Bu sefer AWS kimlik bilgilerini yÃ¼klÃ¼yoruz.
                // [[$class: 'AmazonWebServicesCredentialsBinding', ...]]: AWS Credential tÃ¼rÃ¼nÃ¼ belirtir.
                // credentialsId: 'aws-deploy-credentials': Jenkins kasasÄ±ndaki AWS anahtarlarÄ±mÄ±zÄ±n ID'si (AdÄ±m 5.3'te ekledik).
                // Bu blok sayesinde iÃ§erideki 'aws' CLI komutlarÄ± otomatik olarak yetkilendirilir.
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-deploy-credentials']]) {
                    // script { ... }: KarmaÅŸÄ±k Groovy mantÄ±ÄŸÄ± (if/else, deÄŸiÅŸken atama) iÃ§in gereklidir.
                    script {
                        // --- AdÄ±m 1: CanlÄ± OrtamÄ± Bul ---
                        echo "Determining current LIVE environment by querying ALB Rule..."
                        // sh(script: "...", returnStdout: true).trim(): Jenkins'in bir shell komutunun
                        // Ã‡IKTISINI yakalayÄ±p bir Groovy deÄŸiÅŸkenine atamasÄ±nÄ± saÄŸlar.
                        def liveTargetGroupArn = sh(
                            script: """
                                # aws elbv2 describe-rules: AWS CLI komutu, ALB kuralÄ±nÄ±n detaylarÄ±nÄ± getirir.
                                aws elbv2 describe-rules --rule-arn ${env.ALB_RULE_ARN} \\
                                    # --query '...': AWS CLI'nÄ±n JSON Ã§Ä±ktÄ±sÄ±nÄ± filtreleyerek sadece ihtiyacÄ±mÄ±z olan
                                    # (ilk kuralÄ±n ilk eyleminin hedef grup ARN'si) deÄŸeri alÄ±rÄ±z.
                                    --query 'Rules[0].Actions[0].TargetGroupArn' --output text --region ${env.AWS_REGION}
                            """,
                            returnStdout: true // Ã‡Ä±ktÄ±yÄ± yakala
                        ).trim() // BaÅŸtaki/sondaki boÅŸluklarÄ± temizle

                        // Groovy deÄŸiÅŸkenleri tanÄ±mlÄ±yoruz (sonraki adÄ±mlarda kullanmak iÃ§in).
                        def deployTargetGroupArn // Hangi hedef gruba deploy edeceÄŸiz?
                        def deployServerIp       // Hangi sunucu IP'sine deploy edeceÄŸiz?
                        def deployTgFriendlyName // Loglarda 'BLUE'/'GREEN' yazdÄ±rmak iÃ§in.
                        def liveServerIp         // Åu an canlÄ± olan sunucunun IP'si (sadece log iÃ§in).

                        // if/else if bloÄŸu: YakaladÄ±ÄŸÄ±mÄ±z 'liveTargetGroupArn' deÄŸerine gÃ¶re karar veriyoruz.
                        if (liveTargetGroupArn == env.BLUE_TG_ARN) { // EÄŸer canlÄ± olan Blue ise...
                            echo "Blue environment (${env.BLUE_SERVER_IP}) is LIVE. Deploying to GREEN."
                            // ... deploy'u Green'e yapacaÄŸÄ±z. DeÄŸiÅŸkenleri Green'in bilgileriyle dolduruyoruz.
                            deployTargetGroupArn = env.GREEN_TG_ARN
                            deployServerIp = env.GREEN_SERVER_IP
                            deployTgFriendlyName = "GREEN"
                            liveServerIp = env.BLUE_SERVER_IP
                        } else if (liveTargetGroupArn == env.GREEN_TG_ARN) { // EÄŸer canlÄ± olan Green ise...
                            echo "Green environment (${env.GREEN_SERVER_IP}) is LIVE. Deploying to BLUE."
                            // ... deploy'u Blue'ya yapacaÄŸÄ±z. DeÄŸiÅŸkenleri Blue'nun bilgileriyle dolduruyoruz.
                            deployTargetGroupArn = env.BLUE_TG_ARN
                            deployServerIp = env.BLUE_SERVER_IP
                            deployTgFriendlyName = "BLUE"
                            liveServerIp = env.GREEN_SERVER_IP
                        } else {
                            // error '...': Bir sorun varsa (Ã¶rn: kural beklenmedik bir yere gidiyorsa)
                            // pipeline'Ä± HATA mesajÄ±yla durdurur. GÃ¼venlik Ã¶nlemi.
                            error "ALB Rule is pointing to an unknown Target Group ARN: ${liveTargetGroupArn}"
                        } // CanlÄ±/BoÅŸta ortamlar belirlendi. 'deployServerIp' artÄ±k boÅŸta olan sunucuyu gÃ¶steriyor.

                        // --- AdÄ±m 2: BoÅŸtaki Sunucuya Deploy Et ---
                        echo "Deploying image ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG} to IDLE [${deployTgFriendlyName}] server: ${deployServerIp}"
                        // withCredentials (iÃ§ iÃ§e): Hem Docker Hub hem de SSH anahtarÄ±nÄ± aynÄ± anda yÃ¼klememiz gerekiyor.
                        withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                            // sshagent { ... }: Jenkins kasasÄ±ndaki SSH Ã¶zel anahtarÄ±nÄ± ('deploy-server-ssh-key' - AdÄ±m 3.3'te ekledik)
                            // gÃ¼venli bir ÅŸekilde yÃ¼kler. Ä°Ã§indeki 'sh "ssh ..."' komutu bu anahtarÄ± kullanarak ÅŸifresiz baÄŸlanÄ±r.
                            sshagent(credentials: ['deploy-server-ssh-key']) {
                                // sh """ssh ... '...'""": Uzak sunucuda (boÅŸtaki sunucu - deployServerIp) komut Ã§alÄ±ÅŸtÄ±rÄ±r.
                                sh """
                                    # -o StrictHostKeyChecking=no: Ä°lk baÄŸlantÄ±da "yes/no" sormasÄ±nÄ± engeller (otomasyon iÃ§in).
                                    ssh -o StrictHostKeyChecking=no ec2-user@${deployServerIp} '
                                        # Tek tÄ±rnak (') iÃ§indeki HER ÅEY UZAK SUNUCUDA (B veya C) Ã§alÄ±ÅŸÄ±r.
                                        echo "ğŸ¯ [${deployServerIp}] Connected!"
                                        echo "ğŸ” [${deployServerIp}] Logging in to Docker Hub..."
                                        # \${...} KULLANIMI Ã‡OK Ã–NEMLÄ° (AdÄ±m 4'teki Sorun 11/12'yi Ã§Ã¶zdÃ¼):
                                        # Jenkinsfile Groovy'dir. EÄŸer sadece ${DOCKER_PASS} yazsaydÄ±k, Groovy bunu Sunucu A'da
                                        # Ã§Ã¶zmeye Ã§alÄ±ÅŸÄ±rdÄ± ve SSH komutuna ÅŸifreyi aÃ§Ä±k metin olarak gÃ¶merdi (gÃ¼vensiz).
                                        # BaÅŸÄ±na '\' koyarak Groovy'e "buna dokunma" diyoruz. Bu sayede ${DOCKER_PASS} ifadesi
                                        # olduÄŸu gibi uzak sunucunun SHELL'ine gider ve SHELL bunu doÄŸru ÅŸekilde Ã§Ã¶zer.
                                        echo "\${DOCKER_PASS}" | docker login -u "\${DOCKER_USER}" --password-stdin

                                        echo "ğŸ³ [${deployServerIp}] Pulling image: ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}"
                                        # Uzak sunucu, Docker Hub'dan yeni imajÄ± Ã§eker.
                                        docker pull ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}

                                        echo "ğŸ›‘ [${deployServerIp}] Stopping old container..."
                                        # || true: EÄŸer Ã¶nceki deploy'dan kalan konteyner yoksa hata vermeden devam etmesini saÄŸlar.
                                        docker stop jenkins-demo-app || true
                                        docker rm jenkins-demo-app || true

                                        echo "ğŸš€ [${deployServerIp}] Starting new container on port 8001..."
                                        # Yeni imajla konteyneri baÅŸlatÄ±r. Host'un 8001 portunu konteynerin 8000'ine baÄŸlar.
                                        docker run -d --name jenkins-demo-app -p 8001:8000 ${env.DOCKER_IMAGE_NAME}:${env.DOCKER_TAG}

                                        echo "ğŸ§¹ [${deployServerIp}] Pruning old images..."
                                        # Uzak sunucudaki eski, kullanÄ±lmayan Docker imajlarÄ±nÄ± temizler (disk tasarrufu).
                                        docker image prune -f

                                        echo "âœ… [${deployServerIp}] Deployment script finished."
                                    '
                                """
                            } // sshagent biter, SSH anahtarÄ± hafÄ±zadan silinir.
                        } // withCredentials (Docker Hub) biter.

                        // --- AdÄ±m 3: SaÄŸlÄ±k KontrolÃ¼ ---
                        echo "Waiting for application to start on [${deployTgFriendlyName}] server (${deployServerIp}) before health check..."
                        // sleep(15): Docker konteynerinin ayaÄŸa kalkmasÄ± ve uygulamanÄ±n cevap vermeye baÅŸlamasÄ±
                        // biraz zaman alabilir. Kontrol etmeden Ã¶nce kÄ±sa bir sÃ¼re beklemek Ã¶nemlidir.
                        sleep(15)

                        echo "Performing health check on [${deployTgFriendlyName}] server: http://${deployServerIp}:8001/health"
                        // try { ... } catch (ex) { ... }: Hata yakalama bloÄŸu. SaÄŸlÄ±k kontrolÃ¼ baÅŸarÄ±sÄ±z olursa
                        // pipeline'Ä±n devam etmesini engeller.
                        try {
                            // sh "curl ...": Jenkins sunucusundan (A), yeni deploy edilen sunucunun (B veya C)
                            // IP adresine DOÄRUDAN bir HTTP isteÄŸi gÃ¶ndeririz (/health endpoint'ine).
                            // -f: HTTP 4xx/5xx hatasÄ± alÄ±rsa curl'un hata koduyla Ã§Ä±kmasÄ±nÄ± saÄŸlar (catch'i tetikler).
                            // -sS: Sessiz Ã§alÄ±ÅŸÄ±r ama hata olursa gÃ¶sterir.
                            sh "curl -fsS http://${deployServerIp}:8001/health"
                            echo "âœ… [${deployTgFriendlyName}] Health check PASSED."
                        } catch (ex) { // EÄŸer 'sh "curl..."' komutu hata verirse (uygulama cevap vermezse veya hata dÃ¶nerse) burasÄ± Ã§alÄ±ÅŸÄ±r.
                            echo "âŒ [${deployTgFriendlyName}] Health check FAILED! See details below:"
                            echo ex.getMessage() // HatayÄ± konsola yazdÄ±rÄ±r.
                            // error '...': Pipeline'Ä± BAÅARISIZ olarak iÅŸaretler ve durdurur. Trafik Ã§evrilmez!
                            error "Deployment failed health check. Traffic switch aborted."
                        } // try-catch biter. Buraya ulaÅŸtÄ±ysak saÄŸlÄ±k kontrolÃ¼ baÅŸarÄ±lÄ±dÄ±r.

                        // --- AdÄ±m 4: TrafiÄŸi Ã‡evirme ---
                        echo "Health check passed. Flipping ALB traffic to target group [${deployTgFriendlyName}] (${deployTargetGroupArn})..."
                        // sh """aws ...""": AWS CLI komutunu kullanarak ALB kuralÄ±nÄ± gÃ¼ncelleriz.
                        sh """
                            aws elbv2 modify-rule --rule-arn ${env.ALB_RULE_ARN} \\
                                # --actions Type=forward,TargetGroupArn=...: KuralÄ±n hedefini, yeni deploy ettiÄŸimiz
                                # ve saÄŸlÄ±k kontrolÃ¼nÃ¼ geÃ§en hedef gruba (deployTargetGroupArn) yÃ¶nlendirir.
                                --actions Type=forward,TargetGroupArn=${deployTargetGroupArn} \\
                                --region ${env.AWS_REGION}
                        """
                        // BU KOMUT TRAFÄ°ÄÄ° ANINDA Ã‡EVÄ°RÄ°R! SÄ±fÄ±r kesinti burada gerÃ§ekleÅŸir.
                        // âš ï¸ KarÅŸÄ±laÅŸÄ±lan Sorun 15'i hatÄ±rlayalÄ±m: EÄŸer burada varsayÄ±lan kuralÄ±n ARN'sini
                        // kullansaydÄ±k, bu komut 'Default rule cannot be modified' hatasÄ± verirdi.

                        echo "âœ… SUCCESS! Traffic is now flowing to [${deployTgFriendlyName}]."
                        echo "Old environment (Server IP: ${liveServerIp}) is now idle." // Eski canlÄ± sunucunun artÄ±k boÅŸta olduÄŸunu loglarÄ±z.
                    } // script bloÄŸu biter.
                } // withCredentials [AWS] bloÄŸu biter. AWS anahtarlarÄ± hafÄ±zadan silinir.
            } // steps bloÄŸu biter.
        } // stage 'Deploy Blue/Green' biter.
    } // stages bloÄŸu biter.

    // === POST ACTIONS (Pipeline Bittikten Sonra Ã‡alÄ±ÅŸÄ±r) ===
    // post { ... }: Pipeline bittikten sonra (baÅŸarÄ±lÄ± veya baÅŸarÄ±sÄ±z) yapÄ±lacak ek iÅŸlemleri tanÄ±mlar.
    post {
        // always { ... }: Pipeline baÅŸarÄ±lÄ± da olsa baÅŸarÄ±sÄ±z da olsa HER ZAMAN Ã§alÄ±ÅŸÄ±r.
        always {
             // junit ...: Unit test aÅŸamasÄ±nda oluÅŸturulan 'test-results.xml' dosyasÄ±nÄ± okur
             // ve Jenkins arayÃ¼zÃ¼nde gÃ¼zel bir test raporu gÃ¶sterir.
             junit testResults: 'test-results.xml', allowEmptyResults: true
             // publishHTML ...: Unit test aÅŸamasÄ±nda oluÅŸturulan 'htmlcov' klasÃ¶rÃ¼ndeki
             // HTML kapsam raporunu Jenkins arayÃ¼zÃ¼nde yayÄ±nlar.
             publishHTML(
                allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true,
                reportDir: 'htmlcov', reportFiles: 'index.html', reportName: 'Coverage Report'
             )
             // Bu raporlamalar, build sonuÃ§larÄ±nÄ± takip etmek ve analiz etmek iÃ§in Ã§ok deÄŸerlidir.
        }
        // success { ... }: Sadece pipeline BAÅARILI olursa Ã§alÄ±ÅŸÄ±r.
        success {
            echo 'âœ… Pipeline completed successfully!'
        }
        // failure { ... }: Sadece pipeline BAÅARISIZ olursa Ã§alÄ±ÅŸÄ±r.
        failure {
            echo 'âŒ Pipeline failed!'
        }
    }
} // pipeline biter.